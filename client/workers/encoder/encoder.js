/*
 *  This file is part of Bumble, a browser based client for mumble.
 *
 *  Bumble is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Bumble is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Bumble. If not, see <http://www.gnu.org/licenses/>.
 */
importScripts('oggencoder.js', 'opusencoder.js', '../resampler.js');

/**
 * Called when a packet was generated by the ogg encoder.
 * @callback Encoder~PacketCallback
 * @param {Uint8Array} output - A buffer containing the generated packet.
 */
/**
 * Called when an error occured during encoding or setup of the encoder.
 * @callback Encoder~ErrorCallback
 * @param {object} error - The error thrown by the encoder.
 */
/**
 * This handles the redirecting of the raw pcm input data into the chain of encoders.
 * The chain is: Javascript --> Encoder (this) --> Resampler --> Opus encoder --> Ogg encoder --> Javascript.
 * @constructor
 * @param {object} e - This object holds the attributes needed to set up all parts of the encoding chain.
 * @param {number} e.outputSampleRate - The sample rate to output from this encoder.
 * @param {number} e.inputSampleRate - The sample rate to input into this encoder.
 * @param {Encoder~PacketCallback} e.onpacket - This callback is called whenever a new packet is ready.
 * @param {Encoder~ErrorCallback} e.onerror - Called when an error occured during encoding.
 */
var Encoder = function(e) {
	this.channels = 1;
	this.outputSampleRate = e.outputSampleRate;
	this.inputSampleRate = e.inputSampleRate;
	this.onerror = e.onerror || function() {};
	this.onpacket = e.onpacket || function() {};
	this.oggEncoder = new OggEncoder({
		channels : this.channels,
		sampleRate : this.outputSampleRate,
		onpacket : this.onpacket
	});
	this.opusEncoder = new OpusEncoder({
		sampleRate : this.outputSampleRate,
		channels :  this.channels,
		onframe : this._onframe.bind(this),
		onerror : this.onerror
	});
	this.resampler = new Resampler({
		resampledRate : this.outputSampleRate,
		originalSampleRate : this.inputSampleRate,
		numberOfChannels : this.channels
	});
};

/**
 * Call this method to encode a buffer of raw pcm audio data.
 * @param {ArrayBuffer} data - The buffer containing the raw pcm audio data to be encoded.
 */
Encoder.prototype.encode = function(data) {
	var resampled = this.resampler.resample(data, 0);
	this.opusEncoder.encode(resampled);
};


Encoder.prototype._onframe = function(frame) {
	this.oggEncoder.encode(frame);
};

// Called when a packet was generated.
this.onpacket = function(data) {
	this.postMessage({
		type : 'packet',
		packet : data
	});
};

// Called when an error occured during encoding.
this.onerror = function(err) {
	this.postMessage({
		type : 'error',
		error : err.message
	});
};

this.onmessage = function(e) {
	var obj = e.data;
	if(obj.command == 'init') { // Initialize a new encoder on init.
		this.encoder = new Encoder({
			outputSampleRate : obj.outputSampleRate,
			inputSampleRate : obj.inputSampleRate,
			onpacket : this.onpacket.bind(this),
			onerror : this.onerror.bind(this)
		}, this);
	}
	else if(obj.command == 'encode') {
		if(!this.encoder) {
			this.onerror(new Error("encoder is unitialized"));
		}
		else {
			this.encoder.encode(obj.data); // Encode a buffer of raw pcm audio.
		}
	}
}.bind(this);
